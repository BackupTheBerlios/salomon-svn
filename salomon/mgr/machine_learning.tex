%Cichosz (35-36)
\section{Algorytmy ucz¹ce siê}

%Próby opracowania algorytmów ucz¹cych siê nie wynikaj¹ z chêci wyeliminowania
%projektantów z procesów analizy i projektowania systemów komputerowych, a wiêc
%klasycznych zagadnieñ in¿ynierii oprogramowania. Nie mog¹ one bowiem byæ
%alternatyw¹ dla tradycyjnych metodologii tworzenia oprogramowania. Cele, jakie
%stawiaj¹ sobie twórcy algorytmów ucz¹cych siê wynikaj¹ ze z³o¿onoœci niektórych
%zagadnieñ algorytmicznych -- próbuj¹ oni w³aœnie za ich pomoc¹ opisaæ te
%problemy, dla których opracowanie poprawnych i pe³nych algorytmów klasycznych
%jest bardzo trudne lub wrêcz niemo¿liwe.
%
%Program ucz¹cy mo¿na wyobraziæ sobie jako abstrakcyjny, ,,parametryzowalny''
%algorytm wykonania zadania. Proces uczenia polega na dobraniu, na podstawie
%historycznych wartoœci tych ,,parametrów'', takich wartoœci, by rozwi¹zanie
%spe³nia³o za³o¿enia projektanta. 
%
%,,Parametry'' te mo¿na traktowaæ jako pewnego rodzaju \emph{wiedzê}.
%Nie s¹ one podawane do algorytmu w sposób bezpoœredni (a jeœli nawet s¹ podawane
%ich pocz¹tkowe wartoœci, to s¹ one najczêœciej dalekie od oczekiwanych), ale
%odkrywane s¹ przez sam algorytm podczas procesu uczenia siê.
%Z tego te¿ powodu s¹ one traktowane jako wiedza niepewna i mog¹ca wymagaæ weryfikacji.	
%
%Wiedza ta mo¿e okreœlaæ zarówno sekwencje operacji, które program ma wykonaæ
%podczas rozwi¹zywania danego problemu, jak i wybór spoœród ró¿nych wariantów
%mo¿liwych do podjêcia w danym momencie decyzji.
%
%Wiedza, która okreœla strategie osi¹gania celów nazywana jest
%\emph{proceduraln¹}, natomiast taka, która opisuje obiekty i zwi¹zki miêdzy nimi
%-- \emph{deklaratywn¹}.
%
%Algorytmy pozyskiwania i doskonalenia zdobytej wiedzy nazywane s¹
%\emph{algorytmami uczenia maszynowego}. 

%Troche przykladow
\subsection{Metody reprezentacji wiedzy}

% Cichosz 41-42
Wiedza uzyskana w wyniku zastosowania algorytmów uczenia maszynowego
mo¿e byæ reprezentowana na ró¿ne sposoby -- opracowano w tym celu 
wiele efektywnych struktur danych, pozwalaj¹cych na jej ³atwe zapisanie i przetwarzanie.
Z regu³y jednak dziedzina, w jakiej ma byc wykorzystany algorytm ucz¹cy,
determinuje, lub w najlepszym przypadku zawê¿a, iloœæ mo¿liwych reprezentacji
wiedzy, z których ka¿da ma swoje dobre strony jak i ograniczenia.
Do podstawowych metod reprezentacji wiedzy nale¿¹ drzewa decyzyjne (\ref{lab:dec_trees}),
formu³y logiki predykatów, sieci neuronowe czy sieci Bayesa (TODO: rozwijamy te zagadnienia?).

Nie zawsze metoda u¿yta do reprezentacji wiedzy dla okreœlonych zastosowañ jest
jedynym mo¿liwym sposobem jej przedstawienia, jednak rzadko zdarza siê, aby 
do wyboru by³o wiele metod. Wynika to z tego, ¿e sposób, w jaki wiedza mo¿e byæ u¿yta
zale¿y g³ównie od wyboru metody oraz celu, czyli zadania, które ma byæ wykonane
przez algorytm ucz¹cy.

Powy¿sze metody reprezentacji wiedzy mo¿na podzieliæ na metody
\emph{symboliczne} i \emph{subsymboliczne}.
Metody symboliczne do reprezentacji wiedzy stosuj¹ struktury przechowuj¹ce
informacje o charakterze symbolicznym, czyli pewne napisy, które mog¹ byæ w
pewien sposób interpretowane. Napisy te najczêœciej maj¹ formê czyteln¹ dla
cz³owieka i mog¹ byæ przez niego przegl¹dane i poddawane analizie oraz
interpretacji.
Przyk³adem tego typu metod reprezentacji wiedzy mog¹ byæ drzewa decyzyjne.

Metody drugiej z kategorii przechowuj¹ informacje w formie trudnej do
interpretacji przez cz³owieka. Poszczególne dane analizowane
pojedynczo nie nios¹ ¿adnej sensownej informacji, gdy¿ czêsto s¹ to ci¹gi liczb
lub dane binarne. Dopiero odpowiednio po³¹czone ze sob¹ dane poddane
przetwarzaniu reprezentuj¹ pewn¹ wiedzê.
Przyk³adow¹ subsymboliczn¹ metod¹ reprezentacji wiedzy s¹ sieci neuronowe.

% Cichosz 43-44
\subsection{Podzia³ algorytmów ucz¹cych}

Jednym z najbardziej podstawowych kryteriów podzia³u algorytmów ucz¹cych siê jest
ich podzia³ na  \emph{uczenie siê z nadzorem} i \emph{bez nadzoru}.

W przypadku uczenia z nadzorem (czasami nazywanego tak¿e \emph{uczeniem z
nauczycielem}) wiedza uzyskiwana w czasie dzia³ania algorytmu ucz¹cego jest
weryfikowana -- algorytm dla okreœlonych danych wejœciowych otrzymuje tak¿e
oczekiwane informacje wyjœciowe, zwane \emph{informacj¹ trenuj¹c¹}.
Zadaniem procesu uczenia siê jest takie dobranie parametrów algorytmu, aby dla
okreœlonych danych wejœciowych otrzymaæ dane wyjœciowe mo¿liwie zbli¿one do
wzorcowych.

W procesie uczenia bez nadzoru nie jest dostêpna informacja trenuj¹ca. Podawane
s¹ jedynie dane wejœciowe i jedynie na ich podstawie algorytm ma siê
,,nauczyæ'' prawid³owo je interpretowaæ. Z takimi przypadkami mamy do czynienia
g³ównie w algorytmach grupuj¹cych obiekty, gdzie nie s¹ znane kryteria, wed³ug
których obiekty maj¹ zostaæ pogrupowane. Czasem mówi siê, ¿e takie algorytmy
maj¹ wbudowanego nauczyciela, jako ¿e weryfikacja uzyskiwanej wiedzy jest
integraln¹ czêœci¹ algorytmu.

Uczenie z nauczycielem i bez nadzoru to najbardziej popularne grupy algorytmów,
jednak wyró¿nia siê tak¿e inne. Podobn¹ do uczenia z nadzorem grup¹ algorytmów
s¹ metody \emph{uczenia na podstawie zapytañ}. W takim przypadku informacja
trenuj¹ca co prawda pochodzi od nauczyciela, lecz stanowi jedynie odpowiedŸ na
zadane przez ucznia pytanie. W odró¿nieniu od uczenia pod nadzorem, nauczyciel
nie podaje przyk³adów danych wejœciowych i oczekiwanych odpowiedzi, a jedynie
odpowiada na jawne pytanie ucznia.

Mo¿na tak¿e wyró¿niæ metodê \emph{uczenia przez eksperymentowanie}. Mamy z ni¹
do czynienia, gdy algorytm gromadzi wiedzê poprzez wykonywanie eksperymentów ze
œrodowiskiem, w którym dzia³a. Polega to na wykonywaniu pewnych dzia³añ, a
nastêpnie obserwowaniu ich konsekwencji i wp³ywu, jakie maj¹ one na œrodowisko.

Zbli¿on¹ do uczenia przez eksperymentowanie metod¹ jest \emph{uczenie ze
wzmocnieniem}. Podobnie jak poprzednia metoda opiera siê ono na
eksperymentowaniu, jednak wykorzystuje dodatkowo pewn¹ informacjê trenuj¹c¹,
pozwalaj¹c¹ na ocenê uzyskanej wiedzy. W tym przypadku informacja ta nie 
ma charakteru instrukta¿owego, ale pozwala na otrzymanej wartoœciowanie wiedzy
poprzez przypisanie jej liczbowych wspó³czynników zwanych \emph{wzmocnieniami}.
Pozwala to na ocenê dotychczasowego przebiegu procesu uczenia siê i dobieranie
jego parametrów tak, by uzyskiwana by³a wiedza zbli¿ona do tej z najwy¿szymi wspó³czynnikami. 

%\subsection{Metody uczenia siê}
%
%% Cichosz 44
%Informacja trenuj¹ca stanowi dla algorytmu ucz¹cego siê podstawê, któr¹
%wykrzystuje do nabywania nowej wiedzy lub do udoskonalenia ju¿ posiadanej.
%Reprezentacja tej wiedzy oraz sposób jej wykorzystania najczeœciej
%podporz¹dkowany jest zadaniu, do realizacji którego ma zostaæ u¿yta.
%Mechanizm odkrywania nowej lub ulepszania ju¿ posiadanej wiedzy z regu³y mocno
%zale¿y od sposobu jej reprezentacji oraz postaci informacji trenuj¹cej.
%
%Z regu³y do realizacji konkretnego mechanizmu zdobywania wiedzy mog¹ byæ u¿yte
%ró¿norodne algorytmy.
%Najbardziej popularn¹ metod¹ uczenia siê jest \emph{indukcja}. Polega ona na
%wnioskowaniu na podstawie posiadanej, konkretnej, informacji trenuj¹cej. Ma ona
%na celu celu uzyskania wiedzy ogólnej za pomoc¹ uogólnienia informacji
%trenuj¹cej na pozosta³e przypadki.
%
%Oprócz metod indukcyjnych, wyró¿nia siê tak¿e mechanizmy \emph{uczenia
%nieindukcyjnego}. Metody te maja na celu nie tyle wnioskowanie, ile raczej 
%wyjaœnianie -- informacja trenuj¹ca nie jest uogólniania, lecz wykorzystywana
%jest do konkretyzacji ju¿ zdobytej przez algorytm ucz¹cy siê wiedzy.
%% Add reference here - uczenie ze wzmocnieniem
%Do metod tych zalicza siê tak¿e stosowane przy uczeniu ze wzmocnieniem
%wartoœciowanie zdobytej wiedzy pozwalaj¹ce na lepsze wyselekcjonowanie
%po¿ytecznej wiedzy.

%Cichosz 45 - glowne dzialy uczenia maszynowego
\subsection{G³ówne nurty uczenia maszynowego}

%Badania nad ró¿nymi systemami ucz¹cymi doprowadzi³y to powstania nowej dziedziny
%naukowej -- \emph{uczenia maszynowego}. Dziedzina ta mo¿e byæ traktowana jako
%ga³¹Ÿ sztucznej inteligencji, czy szerzej -- informatyki.
%W zg³êbianie zagadnieñ uczenia maszynowego zaanga¿owani s¹ nie tylko
%informatycy, co wydaje siê naturalne, ale tak¿e przedstawiciele innych dziedzin
%takich jak matematyka, a nawet psychologia, czy biologia.

%za Cichoszem
Wydziela siê 3 g³ówne nurty, w którym zmierzaj¹ prace badawcze w dziedzinie
uczenia maszynowego -- nurt \emph{teoretyczny}, \emph{biologiczny} i \emph{systemowy}.

Badacze zajmuj¹cy siê nurtem teoretycznym stawiaj¹ sobie za cel przede
wszystkim rozwijanie podstaw teoretycznych, na których ma opieraæ siê ca³a
dziedzina. Staraj¹ siê oni nazwaæ i usystematyzowaæ pojêcia zwi¹zane z t¹
dziedzin¹ i d¹¿¹ do utworzenia s³ownika pojêæ teoretycznych, który by³by
powszechnie wykorzystywany przez wszystkich zajmuj¹cych siê uczeniem maszynowym.
Oprócz opracowywania podstaw teoretycznych zajmuj¹ siê tak¿e przyk³adowo 
klasyfikacj¹ problemów, którymi zajmuje siê uczenie maszynowe, ze wzglêdu na ich
trudnoœæ, czy te¿ okreœlaniem wp³ywu iloœci informacji trenuj¹cej na szybkoœæ
procesu uczenia siê.

Nurt biologiczny zajmuje siê opracowywaniem modeli obliczeniowych procesów uczenia siê
wystêpuj¹cych w przyrodzie, czyli na przyk³ad u ludzi i zwierz¹t. Modele te
tworzone s¹ na ró¿nym poziomie szczegó³owoœci, pocz¹wszy od pojedyñczych komórek
a na z³o¿onych uk³adach nerwowych skoñczywszy.

Z informatycznego punktu widzenia, najbardziej interesuj¹cym nurtem jest nurt
systemowy. W odró¿nieniu od nurtu biologicznego, którym czêsto zajmuj¹ siê te¿
biolodzy czy psycholodzy, nurtem systemowym zajmuj¹ siê g³ównie informatycy i
jest to nurt dominuj¹cy w dziedzinie uczenia maszynowego. 
Jego g³ównym celem jest opracowywanie algorytmów uczenia maszynowego oraz
badaniem ich wykorzystania w systemach ucz¹cych.

\subsection{Zastosowanie systemów ucz¹cych siê}

%Nie ulega w¹tpliwoœci, ¿e nawet tak stosunkowo m³oda dziedzina informatyki, jak¹
%jest uczenie maszynowe, znajduje ju¿ praktyczne zastosowania.

% Cichosz 41-42
Do najpowszechniejszych zadañ, które stawia siê przed algorytmami ucz¹cymi
nale¿¹ klasyfikacja i aproksymacja. Klasyfikacja ma na celu ustalenie
przynale¿noœci danych obiektów do okreœlonych kategorii, natomiast aproksymacja
polega na odwzorowaniu obiektów na zbiór liczb rzeczywistych.

Algorytmy ucz¹ce mog¹ tak¿e byæ wykorzystane do innych zastosowañ, jak np.
sekwencyjne podejmowanie decyzji, czy te¿ modelowanie z³o¿onych œrodowisk, dla
których opracowanie klasycznych modeli jest trudne, lub nawet niemo¿liwe.
Znajduj¹ one tak¿e zastosowanie jako narzêdzia wspomagaj¹ce cz³owieka w
przetwarzaniu du¿ej iloœci informacji -- mog¹ one przedstawiaæ wiedzê uzyskan¹ z
analizy du¿ej iloœci danych w bardziej czytelnej dla cz³owieka formie.

% Cichosz 40
%Zastosowanie algorytmów uczenia maszynowego jest bardzo szerokie.
%Zdarza siê, ¿e ich wykorzystanie do rozwi¹zania niektórych problemów
%mo¿e byæ tak¿e podyktowane czynnikami ekonomicznymi -- czasem bardziej op³aca
%siê zastosowaæ algorytmy ucz¹ce siê, ni¿ traciæ czas na opracowywanie 
%skomplikowanych algorytmów klasycznych, które i tak w pewnych przypadkach mog¹
%dzia³aæ niepoprawnie.

Uczenie maszynowe ma równie¿ zastosowanie dla bardzo z³o¿onych lub niewystarczj¹co
dobrze poznanych i opisanych problemów.

Z takimi problemami mamy do czynienia np. w zagadnieniach dotycz¹cych realnie dzia³aj¹cych systemów,
w których trzeba liczyæ siê z du¿¹ dynamik¹ i nieprzewidywalnoœci¹ œrodowiska, w którym dzia³a program.
Uzyskanie poprawnie dzia³aj¹cych algorytmów pracuj¹cych w takich systemach mo¿e
okazaæ siê bardzo kosztowne: albo ze wzglêdu na czas i œrodki potrzebne do ich
opracowania, albo ze wzglêdu na zasoby u¿ywane podczas ich pracy. Zdarza siê
tak¿e, ze opracowanie zadowalaj¹cych algorytmów jest wrêcz niemo¿liwe.
Wynika to z tego, ¿e œrodowiska w których czêsto musz¹ dzia³aæ takie algorytmy
s¹ trudne do opisania -- brakuje dla nich modeli teoretycznych, lub te¿
uproszczenia, które musia³y zostaæ w nich przyjête, by wogóle mo¿liwe by³o
opisanie danego œrodowiska nie pozwalaj¹ na uzyskanie wystarczaj¹co dok³adnie
dzia³aj¹cych algorytmów.

W wielu zastosowaniach systemy informatyczne powinny dzia³aæ mo¿liwe
autonomicznie i wymagaæ znikomej ingerencji ze strony cz³owieka. Przyk³adami
takich systemów mog¹ byæ systemy kontroli poszczególnych instalacji w
nowoczesnych biurowcach, systemy sterowania robotami przemys³owymi czy pojazdami
bezza³ogowymi. Wymagany stopieñ autonomii tych systemów jest niemo¿liwy do
uzyskania bez wyposa¿enia ich w mo¿liwoœæ adaptacji, czyli przystosowania siê do
zmieniaj¹cych siê warunków. Systemy posiadaj¹ce zdolnoœæ adaptacji mog¹ byæ
u¿ywane w nieprzewidywalnym œrodowisku lub wielu podobnych œrodowiskach.

%% moze zrobic: data mining i inne zastosowania?
%\subsubsection{Inteligentne maszyny}
%
%- inteligentne sterowanie
%- brzmi jak science-fiction
%- intelig. sterowane budyntki
%- systemy w samochodach - wspomagaj¹ce kierowcê (pomagaj¹ w prowadzeniu auta,
% staraj¹ siê na podstawie warunków oceniæ, czy kierowca dobrze robi, nawet
% awaryjnie zahamowaæ, lub przygotowaæ siê do nieuniknionego zderzenia --
% napinacze pasów, usztywnienie oparcia itp.)
% Dostosowanie sie do stylu jazdy kierowcy (skrzynie przewiduj¹ce nastêpny ruch kierowcy
% - w Ferrari Enzo :-)
% - robociki - l¹downiki kosmiczne, robociki graj¹ce w pilke, gry - inteligentni
% przeciwnicy, nie tylko w prostych grach (szachy) ale bardziej z³o¿onych grach
% strategicznych. (z³o¿onoœæ i zmiennoœæ œrodowisk, w których dzia³aj¹) 
% 	
%\subsubsection{In¿ynieria oprogramowania TODO:}
%
%- inteligentne interfejsy u¿ytkownika (adaptuj¹ce siê do u¿ytkownika, domyœlnie
%wype³niaj¹ce siê pola, wykonywanie tych samych sekwencji poleceñ)
%
%- projektowanie systemów - np. do estymowania kosztów nowego projektu na
%podstawie analizy danych historycznych dotycz¹cych podobnych projektów
%(czasoch³onnoœæ, ile ludzi w poszczególnych okresach) - pozwala na
%efektywniejsze zaplanowanie a wiec na mniejsze ryzyko niedotrzymania terminów
%albo klapy biznesowej

\input{data_mining}

