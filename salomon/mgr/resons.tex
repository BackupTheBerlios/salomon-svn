\section{Powody powstania Salomona}

Po przeanalizowaniu obecnych narzêdzi do uczenia maszynowego stwierdziliœmy, ¿e 
dostêpne systemu tego typu posiadaj¹ pewne ograniczenia, które chcielibyœmy 
wyeliminowaæ. Po zapoznaniu z wieloma narzêdzami doszliœmy do wniosku, ¿e 
najbli¿ej naszych wymagañ s¹ dwie aplikacje: VINLEN oraz Weka. Dlatego 
omawiaj¹c nasze wymagania, bêdziemy nawi¹zywaæ do tych dwóch aplikacji. Równie¿ 
dlatego, ¿e chcielibyœmy, tworz¹c nasz¹ aplikacje, wzorowaæ siê na tych dwóch 
programach.

\subsection{Funkcjonalne}

\begin{enumerate}
	\item Postanowiliœmy, ¿e nasza aplikacja powinna posiadaæ 
mo¿liwoœæ pracy w œrodowisku rozproszonym. W dobie rozpowszechniania siê 
technologi gridowych, klastrów stwierdziliœmy, ¿e to bardzo wa¿ny aspekt takiej 
aplikacji. Dzia³anie w œrodowisku heterogenicznym pozwala nie tylko na lepsze 
wykorzystanie zasobów sprzêtowych, ale równie¿ na dostêp do wielu Ÿróde³ danych 
przy zapewnieniu bezpieczeñstwach tych danych. Rozproszone instancje powinny 
wymieniaæ jak najmniejsza iloœæ informacji. W celu zapewnianiu bezpieczeñstwa 
danych, aplikacja nie powinna wysy³aæ samych danych, ale wy³¹cznie wiedze. 
Nale¿y za³o¿yæ ograniczone zaufanie do instancji pracuj¹cych w œrodowisku, 
dlatego ka¿de Ÿród³o danych powinno byæ zabezpieczone. 
	\item Bezpieczeñstwo, 
czêœciowo omówione wy¿ej jest wa¿nym aspektem systemu tego typu. W 
zastosowaniach komercyjnych system mo¿e mieæ dostêp do kluczowych danych 
przedsiêbiorstwa czy instytucji. Model bezpieczeñstwa komunikacji miêdzy 
ró¿nymi instancjami, chcielibyœmy oprzeæ na obecnie dostêpnych metodach ochrony 
jak np. VPN (Virtual Private Network). Ochron¹ warstwy komunikacji powinien 
zaj¹æ siê administrator. Zak³adamy, ¿e nasz system bêdzie zainstalowany w 
bezpiecznym œrodowisku. 
	\item Obliczenia równoleg³e. Ten aspekt aplikacji zosta³ 
czêœciowo umówiony wy¿ej. W tym punkcie chcielibyœmy zaznaczyæ, ¿e równoleg³e 
obliczenia powinny byæ równie¿ dostêpne w ramach pojedynczej instancji systemu. 
Po przeanalizowaniu dostêpnych metod zrównolegniania aplikacji doszliœmy do 
wniosku, ¿e w naszym przypadku w³aœciwym i najprostszym modelem jest napsianie 
aplikacji pracuj¹cych w oparciu o w¹tki i przeniesienie ciê¿aru zrownolegniania 
na inne mechanizmy jak klasteryzcja itp. Obecnie na rynku znajduj¹ siê systemu 
pozowalaj¹ce na zrównoleglenie aplikacji wielow¹tkowej w sposób przeŸroczysty 
dla u¿ytkownika jak i dla aplikacji. Œwietnym przyk³adem takiej aplikacji jest 
np. MOSIX (http://www.mosix.org/), który z klastrów linuxowych x86 tworzy 
system wieloprocesorowy.   
\end{enumerate}


\subsection{Architektura}
\begin{enumerate}
	\item Wykorzystanie gotowych algorytmów. W VINLENIE zosta³y czêœciowo 
wykorzystane implementacje algorytmów przygotowanych do wczeœniejszych 
projektów jak program Emerald (przypisek). Znajdziemy tam takie algorytmy jak 
Abacuse, AQ czy Cluster. Czêœæ z tych implementacji jest bardzo nowatorska z 
wielkimi mo¿liwoœciami. W Wece mo¿emy znaleŸæ jeszcze wiêksz¹ gamê dostêpnych 
algorytmów. Dlatego te¿, nas system powinien charakteryzowaæ siê odpowiednia 
architektur¹, która w ³atwy sposób pozwala na powtórne u¿ycie ju¿ 
zaimplementowanych algorytmów. Wa¿nym aspektem jest dostêp do algorytmów Weki, 
ale tak¿e do ewentualnego u¿ycia algorytmów z VINLENA, co jedna wymaga 
zastosowania odpowiedniej licencji (link do odpowiedniego punktu. VINLEN zosta³ 
napisany w jêzyku C++, zatem system powinnen wspieraæ równie¿ inne jêzyki 
programowania a szczególnie wspomniany C++.
	\item Jednym z podstawowych wymagañ stawianym naszemu systemowi, jest 
komponentowa architektura. W celu poprawnego dzia³ania w wielkim rozproszonym 
œrodowisku, platforma uruchomieniowa powinna byæ dobrze odseparowana od samych 
algorytmów, co umo¿liwi na wspó³pracê w jednym œrodowisku ró¿nych wersji 
systemu, a nawet ró¿nych jego implementacji! Budowa systemu powinna w jak 
najwiêkszym stopniu wspieraæ mo¿liwoœæ powstania ró¿nych niezale¿nych 
implementacji algorytmów uczenia maszynowego, dostarczanych przez ró¿nych 
dostawców. Tutaj pojawia siê problem bezpieczeñstwa oraz zaufania do ró¿nych 
implementacji. Naturalnym rozwi¹zaniem tego problemu wydajê siê zastosowanie 
bezpiecznych jêzyków programowania, jak Java oraz jej systemu bezpieczeñstwa i 
ograniczenia uprawnieñ. Kolejnym aspektem architektury jest sposób aktualizacji 
algorytmów. Jeœli w przypadku samej platformy aktualizacja nie bêdzie 
dokonywana czêsto to jednak w przypadku algorytmów mo¿e to nastêpowaæ bardzo 
czêsto. Przyk³adowym zastosowaniem wymagaj¹cym czêstych aktualizacji jest 
wynajmowanie mocy obliczeniowej innym instytucj¹. Mo¿na wyobraziæ sobie 
sytuacje, w której na wydajnej maszynie zainstalowany jest Salomon (mo¿na 
podawaæ tutaj nazwê?) Wykonuje on obliczenia na zlecenie, co w oczywisty sposób 
wymaga³oby pobrania nie tylko parametrów, czy danych, ale równie¿ samych 
algorytmów. Oba referencyjne systemy nie spe³niaj¹ wymaganych przez nas 
kryteriów.
\end{enumerate}


\subsection{Jeszcze nie znam tytuly}

W odró¿nieniu od innych systemów, szczególny nacisk chcemy po³o¿yæ na 
platformê, a nie na same algorytmy. Jak ju¿ wczeœniej zosta³o powiedziane, 
wa¿ne jest, aby da³o siê wykorzystaæ gotowe implementacje algorytmów machine 
learning. W zwi¹zku z tym bardzo wa¿nymi aspektami s¹: proste API (z ang. 
Application program interface) oraz licencja.

\begin{enumerate}
\item \item Osoby, które zajmuj¹ siê machine learning, niekoniecznie musz¹, byæ 
specjalistami od jêzyków programowania jak przyk³adowo Java, dlatego 
niezmiernie wa¿ne, jest, aby platforma dostarcza³a bardzo prostego API i 
ukrywa³a przed twórc¹ wtyczek takie aspekty jak zapisywanie parametrów 
wejœciowych oraz wyników. Platforma powinna zawieraæ efektywne, ale zarazem 
proste narzêdzia do dokonywania takich zadañ. Kolejnym aspektem, który mo¿e 
stwarzaæ problemy, a który mo¿na ujednoliciæ jest kwestia komunikacji pomiêdzy 
ró¿nymi algorytmami (wtyczkami). I w tym przypadku ca³a odpowiedzialnoœæ za 
komunikacje powinna spoczywaæ na platformie. Dziêki takiemu podejœciu, mo¿liwe 
jest u¿ycie obliczeñ równoleg³ych i rozproszonych, bez dodatkowych wymagañ 
stawianych wtyczk¹. Inna u¿yteczn¹ w³aœciwoœci¹, która nale¿y rozwa¿yæ jest 
umo¿liwienie tworzenia wtyczek za pomoc¹ jêzyków skryptowych. Jest to 
szczególnie po¿yteczna w³aœciwoœæ w przypadku kiedy, pracujemy nad danych 
algorytmem i dokonujemy eksperymentów a przez co potrzebuje czêsto modyfikowaæ 
wtyczkê. Czêsto pomijanym problem przy tworzeniu aplikacji w ogóle, jest 
pierwszy kontakt z ni¹. Chcielibyœmy, aby ka¿dy nowy u¿ytkownik naszego 
systemu, nie zosta³ zniechêcony ju¿ na samym pocz¹tku, dlatego nale¿y zwróciæ 
szczególn¹ uwagê, aby nasza aplikacja by³a prosta w obs³udze z ang. User 
friendly zarówno dla twórcy wtyczek jak i osoby wykonuj¹cych eksperymentów z 
wykorzystaniem gotowych wtyczek. System powinien byæ dostarczany z przyk³adowym 
zestawem wtyczek, które pozwol¹ na u¿ycie i przetestowanie ka¿dego z aspektów 
platformy. 

\item VINLEN to system komercyjny, dostarczany bez kodu Ÿród³owego, 
dlatego jego wykorzystanie jest utrudnione zarówno jako platformy dla w³asnych 
algorytmów jak i  jego algorytmów. Z racji braku kodu Ÿród³owego nie s¹ mo¿liwe 
ewentualne modyfikacje do naszych potrzeb. Weka dostarczana jest na licencji 
GPL, jest licencja open source, jednak równie¿ stwarza pewne problemy. W 
przypadku tej licencji niemo¿liwe jest u¿ycie aplikacji w innym system o 
zamkniêtym kodzie Ÿród³owym. Chcielibyœmy, aby mo¿liwe by³o wykorzystanie 
naszego systemu w zamkniêtych, komercyjnych projektach a zarazem chcielibyœmy, 
aby u¿yta przez na licencja by³a zgodna z GPL. Zgodnoœæ licencji jest wymagana 
do ewentualnego u¿ycia algorytmów Weki w naszym systemie. Po wstêpnej analizie 
dostêpnych licencji, jedn¹ z nich, która spe³nia nasze wymagania jest licencja 
LGPL (wstawiæ przypis i odnoœniki)
\end{enumerate}

\subsection{Wiedza}


Wiedza Jak wczeœniej by³o napisane, system powinien dostarczaæ pewnego 
wspólnego API. W tym punkcie chcielibyœmy szczególnie zwróciæ uwagê na API 
pozwalaj¹ce na dokonywanie operacji na wiedzy oraz danych. Takie interfejs w 
znaczny sposób uproœci³by proces tworzenia wtyczek a dodatkowo pozwoli³by na 
stworzenie wydajnego i dobrze przetestowanego API. Kolejnym wa¿nym aspektem, 
jest komunikacja. Posiadanie jednego formatu zapisu danych i wiedzy umo¿liwia 
komunikacje pomiêdzy ró¿nymi wtyczkami czy podsystemami. Odizolowanie 
algorytmów (wtyczek) od zapisy/odczytu danych pozwala równie¿ zapewniæ 
odpowiedni poziom bezpieczeñstwa. Przyk³adowo system powinien posiadaæ API 
pozwalaj¹ce na tworzenie, manipulacje, odczyt i zapis drzew decyzyjnych, dziêki 
czemu ró¿ne aspekty pracy na drzewach decyzyjnych mo¿na by by³o umieœciæ w 
osobnych wtyczkach niekoniecznie dostarczanych przez tego samego dostawce, a 
przede wszystkim praca nad jedn¹ czêœci¹ (np. Prezentacj¹ drzew) nie wymaga³oby 
wiedzy na temat innych wtyczek.

\begin{enumerate}
 \item Dataset. Wiêkszoœæ algorytmów machine learning wymaga danych wejœciowych.
 Rozró¿niamy dane trenuj¹ce, które s¹ wykorzystywane do uczenia algorytmu, oraz 
dane testuj¹ce. Zbiór danych testuj¹cych wykorzystywany jest do oceny wyników 
algorytmu. Oba zbiory zazwyczaj stanowi¹ losowy podzbiór dostêpnych danych. W 
znanych nam systemach u¿ywan¹ s¹ jednowymiarowe zbiory trenuj¹ce (jedna tabela, 
bez relacji). Taki model pasuje do wiêkszoœci algorytmów ucz¹cych, jednak 
istnieje pewne ryzyko utraty danych, które nios¹ z sob¹ relacje, dlatego 
chcielibyœmy aby nasz system tworzy³ i operowa³ na wielowymiarowych zbiorach 
trenuj¹cych. Z punktu widzenie algorytmu struktura takiego zbioru nie powinna 
odbiegaæ od wejœciowej bazy danych. Jedyna ró¿nica powinna polegaæ na iloœci 
dostêpnych danych. Takie te¿ jest pierwsze i najbardziej naturalne zrozumienie 
zbioru trenuj¹cego, jako podzbioru danych o niezmienionej strukturze. 
Przyk³adowo w Wece zosta³ zastosowany inny model, w którym data set jest 
podzbiorem atrybutów. My jednak chcielibyœmy zamieniæ kolejnoœæ tzn. Umieœciæ 
krok tworzenie podzbioru przed tworzeniem atrybutów w procesie uczenia 
algorytmu. Kolejnym wymaganiem stawianym naszemu systemowi jest sposób opisu 
takich zbiorów. Chcielibyœmy, aby zapis data setu nie wymaga³ kopiowania danych 
z zewnêtrznej bazy danych a jedynie definiowa³ przepis na utworzenie takowego 
(np. W postaci zapytania zbioru warunków) Wa¿ne jest, aby dostêpne by³y 
operacje na zbiorach jak suma czy przeciêcie.  Przyk³adowo chcielibyœmy 
zdefiniowaæ zbiór trenuj¹cy sk³adaj¹cy siê z mê¿czyzn w pewnym przedziale 
wiekowym oraz inny, który zawiera³by kobiety w tym przydziale a do algorytmu 
przes³aæ sumê tych zbiorów. Wa¿ne jest równie¿, aby sposób definicji pozwala³ 
u¿ytkownikowi na manipulacje na ju¿ gotowych zbiorze (np. Wygenerowanym przez 
system, albo przez algorytm klastruj¹cy) 

	\item Niestety wiêkszoœæ algorytmów wymaga 
na wejœciu czêœciowo obrobionych danych. Musimy podaæ jakiego typu jest dany 
danych wejœciowych. Czy mamy do czynienia z napisem, liczb¹ czy mo¿e 
wyliczeniem a w przypadku wyliczeñ musimy podaæ zbiór mo¿liwych wartoœci. Mo¿na 
równie¿ dokonaæ normalizacji pewnych wartoœci a co najwa¿niejsze w wiêkszoœci 
przypadków wymagana jest równie¿ zmiana struktury danych.  W wiêkszoœci baz 
danych mamy do czynienia z danymi wielowymiarowymi, które nale¿y 
przetransformowaæ do postaci jednowymiarowej. Wynik takiej transformacji 
„surowych” danych z bazy danych do danych wejœciowych dla algorytmu nazywamy 
atrybutami. Dla u¿ytkownika proces stworzenia atrybutów z wszystkich danych 
zgromadzonych w zewnêtrzne bazie danych a z danych z data setu powinien 
wygl¹daæ dok³adnie tak samo.
\end{enumerate} 

% \subsection{Wiedza}
% Jak wczeœniej by³o napisane, system powinien dostarczaæ pewnego wspólnego API. W tym punkcie chcielibyœmy szczególnie zwróciæ uwagê na API pozwalaj¹ce na dokonywanie operacji na wiedzy oraz danych. Takie interfejs w znaczny sposób uproœci³by proces tworzenia wtyczek a dodatkowo pozwoli³by na stworzenie wydajnego i dobrze przetestowanego API. Kolejnym wa¿nym aspektem, jest komunikacja. Posiadanie jednego formatu zapisu danych i wiedzy umo¿liwia komunikacje pomiêdzy ró¿nymi wtyczkami czy podsystemami. Odizolowanie algorytmów (wtyczek) od zapisy/odczytu danych pozwala równie¿ zapewniæ odpowiedni poziom bezpieczeñstwa. Przyk³adowo system powinien posiadaæ API pozwalaj¹ce na tworzenie, manipulacje, odczyt i zapis drzew decyzyjnych, dziêki czemu ró¿ne aspekty pracy na drzewach decyzyjnych mo¿na by by³o umieœciæ w osobnych wtyczkach niekoniecznie dostarczanych przez tego samego dostawce, a przede wszystkim praca nad jedn¹ czêœci¹ (np. Prezentacj¹ drzew) nie wymaga³oby wiedzy na temat innych wtyczek. 
% 
% \begin{enumerate}
%  \item Dataset. Wiêkszoœæ algorytmów machine learning wymaga danych wejœciowych. Rozró¿niamy dane trenuj¹ce, które s¹ wykorzystywane do uczenia algorytmu, oraz dane testuj¹ce. Zbiór danych testuj¹cych wykorzystywany jest do oceny wyników algorytmu. Oba zbiory zazwyczaj stanowi¹ losowy podzbiór dostêpnych danych.
% \end{enumerate} 



%II. Salomon
%1. Napisaæ postulaty - dlaczego piszemy Salomona:
%Funkcje:
%rozproszenie
%- wykorzystanie gotowych algorytmów
%bezpieczeñstwo
%- komponentowa architektura
%- podejœcie do data set i attribute set
%- jedna reprezentacja wiedzy dzielona pomiêdzy ro¿ne algorytmy
%- przenoœnoœæ
%- dostêp nie tylko do wiedzy, ale tak¿e do danych (indukcyjna baza danych)
%Api i licencja:
%- proste API
%- licencja
%






% \section{Powody powstania Salomona}
% Po przeanalizowaniu obecnie dostêpnych narzêdzi do uczenia maszynowego
% stwierdziliœmy, ¿e oprzemy nas system na na dwóch aplikacjach \emph{Weka}
% oraz \emph{Vinlen}. 
% 
% \subsection{Indukcyjne bazy danych}
% Przyk³adem indukcyjnej bazy danych jest system \emph{Vinlen}. Powsta³ on jako 
% realizacja tej koncepcji. System ten s³u¿y³ nam jako wzorcowa implementacja. Z
% zwi¹zku z pewnymi niedoskona³oœciami tego rozwi¹zania zdecydowaliœmy siê na
% stworzenie w³asnej implementacji. 
% 
% W dobie Internetu, coraz wiêcej aplikacji pracuje w œrodowisku rozproszonym.
% Znana nam wersja systemu Vinlen nie posiada³a mo¿liwoœci pracy w œrodowisku
% rozproszonym, co jednak uznaliœmy za powa¿ny brak. Dwa g³ówne powody
% przemawiaj¹ce za rozproszeniem to lepsze wykorzystanie zasobów (klasteryzacja)
% oraz dostêp do rozproszonych danych oraz wiedzy.
% 
% Vinlen jest rozwijany na uniwersytecie TUTAJ WSTAWIÆ NAZWÊ jako zamkniêty
% produkt. My jednak postanowiliœmy udostêpniæ nasz system na otwartej licencji
% \emph{LGPL}, która pozwala u¿ywanie go jako biblioteki w komercyjnych
% produktach. Jednak w takim przypadku nie mo¿na wykorzystaæ integracji z Weka z
% racji na jej licencjê (GNU). Weka dostarcza implementacji wielu popularnych
% algorytmów uczenia maszynowego, dlatego te¿ stwierdziliœmy, ¿e zamiast
% dostarczenia w³asnej implementacji dostarczymy integracji z Wek¹, przez co
% zyskamy dostêp do jej bogatej biblioteki gotowych algorytmów. Vinlen korzysta z
% w³asnych implementancji algorytmów, z których czêœæ powsta³a na uniwersytecie !!!!!.

% Komponentowa oraz otwarta architektura
% 
% API
% 
% Otwarta licencja
% 
% Podejœcie do datasetów i atrybutów
% 
% Jedna reprezentacja wiedzy

\subsection{Eksperymenty i doœwiadczenia}
TODO
%1. Rozproszenie
%2. Wykorzystanie gotowych algorytmow (vinlen wszystko sam pisze)
%3. Komponentowa architektura
%4. Proste API
%5. Otwarta licencja
%6. Podejscie do datasetow i atrybutow
%7. Jedna reprezentacja wiedzy (w wece drzewa nie maja wpolnej reprezentacji przez co niezaleznie rozwijane algorytmy moga ze soba wspolpracowac

%2. Uzasadnienie potrzeby stworzenia platformy
%	
%- dwa aspekty tematyki uczenia maszynowego:
%	* indukcyjne bazy danych (i Vinlen)
%	* eksperymenty i doswiadczenia (Weka itd.)
%- z tego ma wynikac koncepcja Salomona:
%	* jako platformy laczacej te aspekty
%	* odpowiedz na ograniczenia np. Vinlena
%- przedstawic postulaty, ktore spelaniac ma platfroma
%	* zalozenia koncepcyjne (np. koncepcja zadan)
%	* zalozenia implementacyjne (przenosnosc, rownoleglosc itp).