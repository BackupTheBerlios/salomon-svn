\section{Struktura systemu}

Salomon sk³ada siê z dwóch zasadniczych czêœci (Rys \ref{fig:Achitecture}). Pierwsz¹ z nich
stanowi platforma. Tworz¹ j¹:
\begin{itemize}
	\item silnik, którego zadaniem jest zarz¹dzanie i~uruchamianie
zadañ
	\item magazyn s³u¿¹cy do przechowywania wiedzy
\end{itemize}

Druga czêœæ to zbiór wtyczek, dostarczaj¹cych logikê potrzebn¹ do skonfigurowania, wykonania i~wyœwietlenia rezultatów
zadania. System jest otwarty - oznacza to, ¿e jego funkcjonalnoœæ mo¿e byæ w ³atwy sposób rozszerzana poprzez dostarczenie nowych wtyczek.

\begin{figure}[H]
	\centering
		\includegraphics[width=0.90\textwidth]{img/salomon/concept/architecture.png}
	\caption{Architektura systemu}
	\label{fig:Achitecture}
\end{figure}


\pagebreak
Podstawowe za³o¿enia projektowe:
\begin{itemize}
    \item ca³a funkcjonalnoœæ w pluginach. J¹dro systemu ma byæ jak najmniejsze.
    Jego zadaniem jest stworzenie œrodowiska do realizacji logiki dostarczanej we wtyczkach
    \item otwarta~architektura. Wprowadzenie warstwy poœredniej pomiêdzy baz¹ danych~a wtyczkami.
    Jej zadaniem jest ukrycie sposobu organizacji danych przez
    wtyczkami. Otwartoœæ~architektury polega na mo¿liwoœci rozszerzenia tej warstwy
    \item niezale¿noœæ od platformy. System ma byæ niezale¿ny od platformy, mo¿liwie ³atwo przenaszalny.
    Poszczególne czêœci systemu mog¹ byæ uruchamiane na ró¿nych
    platformach.
    \item mo¿liwoœæ wykorzystywania rezultatów poprzednich zadañ przez kolejne
    \item ³atwa~adaptacja funkcjonalnoœci zawartej w \emph{Vinlenie}.
    Projekt powsta³ jako platforma uruchomieniowa dla logiki zaimplementowanej w programie \emph{Vinlen},
    tworzonego pod kierownictwem prof. Ryszarda Michalskiego.    
\end{itemize}


Salomon ma na celu wyeliminowanie ograniczeñ oryginalnego
\emph{Vinlena} poprzez wprowadzenie:

\begin{itemize}
    \item kolejkowania zadañ
    \item rozproszenia
    \item równoleg³oœci
    \item rozszerzalnoœci (mechanizm wtyczek)
    \item przenoœnoœci (\emph{Java},\emph{Firebird})
\end{itemize}


System zosta³ podzielony na 3 g³ówne czêœci: platformê, kontrolery
i~pluginy.

\subsection{Platforma}

Dostarcza podstawowej funkcjonalnoœci  umo¿liwiaj¹cej pracê ca³ego
systemu,  ³aduje odpowiedni kontroler, wczytuje wtyczki, uruchamia
zadania. Odpowiada za komunikacje miêdzy innymi instancjami \emph{Salomona}.

\begin{figure}[H]
	\centering
		\includegraphics[width=1.00\textwidth]{img/salomon/uml/manager_engine.png}
	\caption{G³ówne klasy platformy}
	\label{fig:core}
\end{figure}

Za poszczególne zadania odpowiadaj¹ odpowiednie menad¿ery.

Klasy maj¹ce w nazwie s³owo \emph{Manager} pe³ni¹ szczególn¹ funkcjê 
-- najczêœciej odpowiadaj¹ za zarz¹dzanie innymi klasami, z regu³y tymi, 
które stanowi¹ resztê nazwy (np. \emph{PluginManger} zarz¹dza pluginami, \emph{ProjectManger} - projektami).
G³ównym zadaniem menad¿erów jest odseparowanie wtyczek od operacji bezpoœrednio na danych.
Dostarczaj¹ one zestawu metod pozwalaj¹cych na wygodne zarz¹dzanie obiektami,
ich tworzenie, modyfikowanie czy usuwanie.

Menad¿ery nie s¹ dostêpne bezpoœrednio z platformy, ale
przekazywane s¹ wtyczkom poprzez klasê \emph{IDataEngine}.
Dotyczy to tylko klas \emph{IDataSetManager}, \emph{IAttributeSetManager}
i \emph{ITreeManager}, pozosta³e nie s¹ dostêpne dla wtyczek.
Plugin, zale¿nie od potrzeb, pobiera z niego potrzebny mu menad¿er i za jego
poœrednictwem zarz¹dza zbiorem danych, atrybutów lub drzewem decyzyjnym.

\subsubsection{IManagerEngine}

Zarz¹dza pozosta³ymi menad¿erami. Utrzymuje jedn¹ instancjê ka¿dego z nich 
i udostêpnia je pozosta³ym klasom z platformy.
Wszystkie menad¿ery, którmi zarz¹dza maj¹ analogiczn¹ funkcjonalnoœæ -- ka¿dy z
nich pozwala na stworzenie nowego obiektu, którym zarz¹dza (nie ma innej
mo¿liwoœci ich stworzenia, ni¿ przez metody udostêpniane przez menad¿era), jego
zesk³adowanie w bazie danych, zwrócenie wszystkich zarz¹dzanych obiektów, czy
te¿ pojedynczego, bazuj¹c na unikalnym identyfikatorze oraz usuniêcie konkretnego obiektu.

\paragraph{ISolutionManager}

Zarz¹dza obiektami implementuj¹cymi interfejs \emph{ISolution}. 
Dostarcza metod pozwalaj¹cych na utworzenie nowego obiektu \emph{ISolution},
modyfikacjê aktualnego, za³adowanie wczeœniej stworzonego lub zwrócenie wszystkich obiektów \emph{ISolution}.

\paragraph{IProjectManager}

Zarz¹dza projektami. Pozwala na utworzenie nowego
projektu, modyfikacje lub usuniêcie istniej¹cego oraz wylistowanie
wszystkich projektów z bie¿¹cego Solutiona.

\paragraph{IPluginManager}

Zarz¹dza pluginami. Pozwala na zapisanie informacji o nowym pluginie 
(jego nazwa, lokalizacja) oraz na pobranie listy dostêpnych pluginów.
Wtyczki mog¹ byæ ³adowane ze zdalnej lokalizacji, a wiêc zadaniem tego
manad¿era jest tak¿e zarz¹dzanie pobieraniem i buforowaniem wtyczek pobranych
z zewnêtrznych Ÿródel.

\paragraph{ITaskManager}

Zarz¹dza zadaniami. Jego zadaniem jest nie tylko umo¿liwienie wykonywania na nich standardowych operacji
zwi¹zanych z ich tworzeniem, edycj¹ czy usuwaniem.
Odpowiada tak¿e za proces przygotowania zadañ do wykonania, czyli ich poprawn¹ konfiguracjê i powi¹zanie ze sob¹,
czy reszcie ich wykonanie i zapisanie informacji o przebiegu ich przetwarzania.

\subsubsection{IDataEngine}

Obiekt implementuj¹cy ten interfejs przekazywany jest wtyczkom podczas ich wykonania.
Za pomoc¹ pobieranych z niego menad¿erów (\emph{IDataSetManager},\emph{IAttributeManager}, 
\emph{ITreeManager} w przysz³oœci \emph{IRuleSetManager} i inne) 
wtyczki mog¹ operowaæ na danych znajduj¹cych siê w bazie.
Udostêpnienie wtyczkom jedynie interfejsów do operawania na danych pozwala
na ukrycie sposobu sk³adowania danych przed twórcami wtyczek i ich uniezale¿nienie siê
od implementacji. W obecnej wersji dane przechowywane s¹ w relacyjnej bazie danych, ale nic nie stoi 
na przeszkodzie, by w przysz³oœci przechowywaæ je w inny sposób, np. w plikach tekstowych o ustalonym formacie
czy bazie LDAP. Twórcy wtyczek nie musz¹ troszczyæ siê o to, jak dane s¹ przechowywane, gdy¿ implementacja
interfejsów dostarczona jest przez platformê.
Co wiêcej, raz napisane wtyczki bêd¹ dzia³aæ tak¿e z nowszymi jej wersjami,
pod warunkiem zachowania dotychczasowych interfejsów.

\paragraph{DBManager}

Odpowiada za po³¹czenie z baz¹ danych. Dostarcza metody
zapewniaj¹ce dostêp do danych przechowywanych w bazie. Swoj¹
funkcjonalnoœæ udostêpnia odpowiednim menad¿erom, wtyczki nie maj¹ do niego
bezpoœredniego dostêpu.
Udostêpnia obiekt implmentuj¹cy interfejs \emph{IMetaData}, dziêki któremu
wtyczki mog¹ pobraæ informacje o strukturze danych ucz¹cych i trenuj¹cych.

\paragraph{IDataSetManager}

Zarz¹dza zbiorami danych. Pozwala tworzyæ nowe podzbiory danych na
podstawie zawartych w bazie informacji oraz umo¿liwia operowanie
na nich.

\paragraph{IAttributeManager}

Zarz¹dza atrybutami. Pozwala tworzyæ nowe atrybuty i organizowaæ je w zbiory
atrybutów oraz pozwala na operowanie na nich.

\paragraph{ITreeManager}

Zarz¹dza drzewami decyzyjnymi. Umo¿liwia ich tworzenie (ale nie generowanie ich
struktury, tym zajmuj¹ siê pluginy) oraz operowanie na nich.

\subsection{Kontrolery}

Kontrolery odpowiadaj¹ za interakcjê
systemu z otoczeniem. W zale¿noœci od konfiguracji systemu przy
starcie uruchamiany jest jeden z kontrolerów. Kontrolery operuj¹
na danych poprzez wspólny interfejs, a co za tym idzie, dane
utworzone poprzez jeden z nich s¹ dostêpne pomiêdzy kolejnymi
uruchomieniami programu dla pozosta³ych kontrolerów.

\paragraph{LocalController}

Jest najprostszym kontrolerem. Zarz¹dza zadaniami wykonywanymi na lokalnym komputerze. S¹ one
wykonywane sekwencyjnie. Zadaniem tego kontrolera jest dostarczenie
interfejsu u¿ytkownika, pozwalaj¹cego na zarz¹dzanie projektami,
wtyczkami i zadaniami.

\paragraph{MasterController}

Zadaniem tego kontrolera jest dostarczenie interfejsu do
zarz¹dzania zdalnymi kontrolerami (\emph{ServantController}). 
W obecnej wersji systemu jest on niezaimplemenetowany.

\paragraph{ServantController}

Zadaniem tego kontrolera jest odszukanie g³ównego kontrolera
(\emph{MasterController}), zarejestrowanie siê i udostêpnianie mu
swoich us³ug. Ta wersja kontrolera nie posiada GUI, zarz¹dzanie
nim odbywa siê za pomoc¹ klasy \emph{MasterController}.
Podobnie jak w przypadku klasy \emph{MasterController}, kontroler ten dopiero bêdzie zaimplementowany.

\subsection{Wtyczki}

G³ówna funkcjonalnoœæ zosta³a  przeniesiona
do wtyczek, zadaniem systemu jest tylko zarz¹dzanie ich
wykonaniem. Dziêki takiemu podejœciu system jest ³atwo skalowalny
i rozszerzalny o nowe mo¿liwoœci. Ka¿da z wtyczek musi
implementowaæ nastêpuj¹ce interfejsy:

\paragraph{IGraphicPlugin}

Pozwala pobraæ parametry od u¿ytkownika, które nastêpnie zostan¹
przekazane do wtyczek  przed ich wykonaniem. Zawiera dwie metody:
\emph{getSettingsPanel()}  i \emph{getResultPanel()}.  Pierwsza z
metod zwraca panel s³u¿¹cy do konfiguracji pluginu, druga -- panel,
na którym prezentowane s¹ wyniki jego dzia³ania.

\paragraph{IDataPlugin}

Posiada tylko jedn¹ metodê \emph{doJob()}. Przyjmuje ona jako
parametry obiekt klasy \emph{Environment}, reprezentuj¹cy aktualny
stan systemu; \emph{IDataEngine}, który umo¿liwia operowanie na
bazie danych i \emph{ISettings}, reprezentuj¹cy ustawienia
wtyczki. Zwracany jest obiekt klasy \emph{IResult}, stanowi¹cy
rezultat wykonania zadania.